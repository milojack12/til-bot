const fs = require('fs');
const path = require('path');

const MEMORY_DIR = process.argv[2] || './memory';
const OUTPUT_FILE = process.argv[3] || 'til.md';

// Pattern matchers
const patterns = {
  '## ğŸ”§ Tech Patterns': [
    /fixed.*error/i,
    /resolved.*issue/i,
    /successfully.*implemented/i,
    /configured.*(model|server|api)/i,
    /build.*pass/i,
    /migration.*complete/i
  ],
  '## âŒ Mistakes & Lessons': [
    /rate limit/i,
    /failed.*(with|due to)/i,
    /error.*encountered/i,
    /unable to.*identify/i,
    /not found/i,
    /invalid.*config/i
  ],
  '## ğŸ“ Decisions': [
    /use/i,
    /decided/i,
    /choose/i,
    /approach/i
  ]
};

function extractTIL(content) {
  const results = {
    '## ğŸ”§ Tech Patterns': [],
    '## âŒ Mistakes & Lessons': [],
    '## ğŸ“ Decisions': []
  };

  const lines = content.split('\n');
  
  for (const line of lines) {
    for (const [section, regexes] of Object.entries(patterns)) {
      for (const regex of regexes) {
        if (regex.test(line)) {
          // Clean up the line
          const clean = line
            .replace(/^[-*] /, '')
            .replace(/^[\s]+/, '')
            .trim();
          if (clean && !results[section].includes(clean)) {
            results[section].push(clean);
          }
          break;
        }
      }
    }
  }

  return results;
}

function generateReport(allResults) {
  const today = new Date().toISOString().split('T')[0];
  
  let report = `# TIL Report â€” ${today}\n\n`;
  report += `> Auto-generated by TIL Bot ğŸ¤–\n\n`;
  
  let hasContent = false;
  
  for (const [section, items] of Object.entries(allResults)) {
    if (items.length > 0) {
      report += `${section}\n\n`;
      items.forEach(item => {
        report += `- ${item}\n`;
      });
      report += '\n';
      hasContent = true;
    }
  }
  
  if (!hasContent) {
    report += '*No learnings extracted today*\n';
  }
  
  return report;
}

// Main
console.log('ğŸ” Scanning memory files...\n');

const files = fs.readdirSync(MEMORY_DIR)
  .filter(f => f.endsWith('.md'))
  .sort();

const allResults = {
  '## ğŸ”§ Tech Patterns': [],
  '## âŒ Mistakes & Lessons': [],
  '## ğŸ“ Decisions': []
};

for (const file of files) {
  const filepath = path.join(MEMORY_DIR, file);
  const content = fs.readFileSync(filepath, 'utf8');
  const fileResults = extractTIL(content);
  
  for (const section of Object.keys(allResults)) {
    allResults[section].push(...fileResults[section]);
  }
  
  console.log(`  âœ“ Processed ${file}`);
}

// Deduplicate
for (const section of Object.keys(allResults)) {
  allResults[section] = [...new Set(allResults[section])];
}

const report = generateReport(allResults);
fs.writeFileSync(OUTPUT_FILE, report);

console.log(`\nâœ… TIL report written to ${OUTPUT_FILE}`);
console.log(`   Tech patterns: ${allResults['## ğŸ”§ Tech Patterns'].length}`);
console.log(`   Lessons: ${allResults['## âŒ Mistakes & Lessons'].length}`);
console.log(`   Decisions: ${allResults['## ğŸ“ Decisions'].length}`);
